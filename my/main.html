<html>
<head>
    <title>3D Soft Engine using HTML5 Canvas</title>
    <style>
        .dropbtn {
            background-color: #3498DB;
            color: white;
            padding: 16px;
            font-size: 16px;
            border: none;
            cursor: pointer;
        }

        .dropbtn:hover, .dropbtn:focus {
            background-color: #2980B9;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f1f1f1;
            min-width: 160px;
            overflow: auto;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
        }

        .dropdown-content a {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block; 
        }

        .dropdown a:hover {background-color: #ddd;}

        .show {display: block;}

        .slidecontainer{float: right;
            position:relative;}

    </style>
    <script src="p5.js"></script>
    <script src="p5.sound.js"></script>
    <script src="p5.dom.js"></script>
    <script src="babylon.math.js"></script>
    <script>
        var objCount=0;
        var viewMatrix;
        var cam;
        var projectionMatrix;
        var meshes=[];
        var song, analyzer, fft;
        var selectedBB;
        function preload(){
          song = loadSound('1.mp3');
        }
        function setup() {
          var c = createCanvas(windowWidth, windowHeight/10); 
          c.position(10, 0);
          background(100);
          text("Drop your audio file here!",windowWidth/3,20);
          textSize(16);
          c.drop(gotFile);
        }
        function gotFile(file) {
            console.log(file.name);
            if (file.type === 'audio') {
                song = loadSound(file.data, gotAudio,loading);
            } 
            else { console.log('Not an audio file!'); }
        }
        function gotAudio(){ 
            song.loop();
            song.stop();
            fft= new p5.FFT();
            analyzer = new p5.Amplitude();
            analyzer.setInput(song);
        } 
        function loading(progress){
            console.log("loading");
        } 
    
        var SoftEngine;
        (function (SoftEngine) {
            var Camera = (function () {
            function Camera() {
                this.Position = BABYLON.Vector3.Zero();
                this.Target = BABYLON.Vector3.Zero();
                }
            return Camera;
            })();
        SoftEngine.Camera = Camera;   
        
        var Mesh = (function () {
            function Mesh(name) {
                this.name = name;
                this.Vertices = [];
                this.Faces = [];
                this.OABB=[];
                this.Rotation = BABYLON.Vector3.Zero();
                this.Position = BABYLON.Vector3.Zero();
                this.animFreq;
            }
            return Mesh;
            })();
        SoftEngine.Mesh = Mesh; 
        
        var Texture = (function (){
            function Texture(filename, width, height){
                this.width = width;
                this.height = height;
                this.load(filename);
            }
            
            Texture.prototype.load =function (filename){
                var _this=this;
                var imageTexture = new Image();
                imageTexture.width = this.width;
                imageTexture.height = this.height;
                imageTexture.onload = function(){
                    var internalCanvas = document.createElement("canvas");
                    internalCanvas.width = _this.width;
                    internalCanvas.height = this.height;
                    var internalContext = internalCanvas.getContext("2d");
                    internalContext.drawImage(imageTexture, 0, 0);
                    _this.internalBuffer = internalContext.getImageData(0, 0, _this.width, _this.height);
                };
                imageTexture.src = filename;
            };
            Texture.prototype.map = function(tu, tv){
                if(this.internalBuffer){
                    var u = Math.abs((tu*this.width)%this.width) >>0;
                    var v = Math.abs((tu*this.height)%this.height) >>0;
                    var pos = (u+v*this.width)*4;
                    var r = this.internalBuffer.data[pos];
                    var g = this.internalBuffer.data[pos+1];
                    var b = this.internalBuffer.data[pos+2];
                    var a = this.internalBuffer.data[pos+3];
                    return new BABYLON.Color4(r/255.0, g/255.0, b/255.0, a/255.0);
                }
                return new BABYLON.Color4(1, 1, 1, 1);
            };
            return Texture;
        })();   
        SoftEngine.Texture = Texture;
        
        var Device = (function () {
                function Device(canvas) {
                    this.workingCanvas = canvas;
                    this.workingWidth = canvas.width;
                    this.workingHeight = canvas.height;
                    this.workingContext = this.workingCanvas.getContext("2d");
                    this.depthbuffer = new Array(this.workingWidth * this.workingHeight);
                }
                Device.prototype.clear = function () {
                    this.workingContext.clearRect(0, 0, this.workingWidth, this.workingHeight);
                    this.backbuffer = this.workingContext.getImageData(0, 0, this.workingWidth, this.workingHeight);
                    for (var i = 0; i < this.depthbuffer.length; i++) {
                            this.depthbuffer[i] = 10000000;
                        }
                };
                Device.prototype.present = function () {
                    this.workingContext.putImageData(this.backbuffer, 0, 0);
                };
                Device.prototype.putPixel = function (x, y, z, color) {
                    this.backbufferdata = this.backbuffer.data;
                    var index = ((x >> 0) + (y >> 0) * this.workingWidth);
                    var index4 = 4*index;
                    if(this.depthbuffer[index] < z) {
                            return;
                        }
                    this.depthbuffer[index] = z;
                    this.backbufferdata[index4] = color.r * 255;
                    this.backbufferdata[index4 + 1] = color.g * 255;
                    this.backbufferdata[index4 + 2] = color.b * 255;
                    this.backbufferdata[index4 + 3] = color.a * 255;
                };
                Device.prototype.project = function (vertex, transMat, world) {
                    var point2d = BABYLON.Vector3.TransformCoordinates(vertex.Coordinates, transMat);
                    var point3DWorld = BABYLON.Vector3.TransformCoordinates(vertex.Coordinates, world);
                    var normal3DWorld = BABYLON.Vector3.TransformCoordinates(vertex.Normal, world);
                    var x = point2d.x * this.workingWidth + this.workingWidth / 2.0 >> 0;
                    var y = -point2d.y * this.workingHeight + this.workingHeight / 2.0 >> 0;
                    return ({
                        Coordinates: new BABYLON.Vector3(x, y, point2d.z),
                        Normal: normal3DWorld,
                        WorldCoordinates: point3DWorld,
                        TextureCoordinates: vertex.TextureCoordinates
                    })
                };
                Device.prototype.drawPoint = function (point, color) {
                    if(point.x >= 0 && point.y >= 0 && point.x < this.workingWidth && point.y < this.workingHeight) {
                        this.putPixel(point.x, point.y, point.z, color);
                    }
                };
                Device.prototype.render = function (camera, meshes, surf) {
                    viewMatrix = BABYLON.Matrix.LookAtLH(camera.Position, camera.Target, BABYLON.Vector3.Up());
                    projectionMatrix = BABYLON.Matrix.PerspectiveFovLH(0.78, this.workingWidth / this.workingHeight, 0.01, 1.0);
                    this.Collision();
                    for(var index = 0; index < meshes.length; index++) {
                        var cMesh = meshes[index];
                        var worldMatrix = BABYLON.Matrix.RotationYawPitchRoll(cMesh.Rotation.y, cMesh.Rotation.x, cMesh.Rotation.z).multiply(BABYLON.Matrix.Translation(cMesh.Position.x, cMesh.Position.y, cMesh.Position.z));
                        var transformMatrix = worldMatrix.multiply(viewMatrix).multiply(projectionMatrix);
                        if (surf==="volume"){
                            for(var indexVertices = 0; indexVertices < cMesh.Vertices.length-1; indexVertices++) {
                                var point0 = this.project(cMesh.Vertices[indexVertices], transformMatrix, worldMatrix);
                                var center = this.project(cMesh.Vertices[cMesh.Vertices.length-1], transformMatrix, worldMatrix)
                                this.drawPoint(point0.Coordinates, new BABYLON.Color4(indexVertices/(cMesh.Vertices.length-1), 1, indexVertices/(cMesh.Vertices.length-1), 1));
                                this.drawLine(point0.Coordinates, center.Coordinates);
                            }
                        }
                        if (surf==="faces"){
                            for (var indexFaces = 0; indexFaces < cMesh.Faces.length; indexFaces++)
                            {
                                var currentFace = cMesh.Faces[indexFaces];
                                var vertexA = cMesh.Vertices[currentFace.A];
                                var vertexB = cMesh.Vertices[currentFace.B];
                                var vertexC = cMesh.Vertices[currentFace.C];
                                var pixelA = this.project(vertexA, transformMatrix, worldMatrix);
                                var pixelB = this.project(vertexB, transformMatrix, worldMatrix);
                                var pixelC = this.project(vertexC, transformMatrix, worldMatrix);
                                var color = 0.25 + ((indexFaces % cMesh.Faces.length) / cMesh.Faces.length) * 0.75;
                                this.drawTriangle(pixelA, pixelB, pixelC, new BABYLON.Color4(color, color, color, 1), cMesh.Texture);
                            }
                        }

                    }
                };

                Device.prototype.Collision = function(){
                    for(var i=0; i<meshes.length; i++){
                        for(var j=0; j<meshes.length; j++){
                            if(i!=j){
                                var worldMatrixI = BABYLON.Matrix.RotationYawPitchRoll(meshes[i].Rotation.y, meshes[i].Rotation.x, meshes[i].Rotation.z).multiply(BABYLON.Matrix.Translation(meshes[i].Position.x, meshes[i].Position.y, meshes[i].Position.z));
                                var transformMatrixI = worldMatrixI.multiply(viewMatrix).multiply(projectionMatrix);
                                var XI=[Number.MAX_VALUE, Number.MIN_VALUE];
                                var YI=[Number.MAX_VALUE, Number.MIN_VALUE];
                                var ZI=[Number.MAX_VALUE, Number.MIN_VALUE];
                                for(var k = 0; k <8 ; k++) {
                                    var point = this.project(meshes[i].OABB[k], transformMatrixI, worldMatrixI);
                                    if (point.Coordinates.x>XI[1]) XI[1]=point.Coordinates.x;
                                    if (point.Coordinates.x<XI[0]) XI[0]=point.Coordinates.x;
                                    if (point.Coordinates.y>YI[1]) YI[1]=point.Coordinates.y;
                                    if (point.Coordinates.y<YI[0]) YI[0]=point.Coordinates.y;
                                    if (point.Coordinates.z>ZI[1]) ZI[1]=point.Coordinates.z;
                                    if (point.Coordinates.z<ZI[0]) ZI[0]=point.Coordinates.z;
                                }
                                var worldMatrixJ = BABYLON.Matrix.RotationYawPitchRoll(meshes[j].Rotation.y, meshes[j].Rotation.x, meshes[j].Rotation.z).multiply(BABYLON.Matrix.Translation(meshes[j].Position.x, meshes[j].Position.y, meshes[j].Position.z));
                                var transformMatrixJ = worldMatrixJ.multiply(viewMatrix).multiply(projectionMatrix);
                                var XJ=[Number.MAX_VALUE, Number.MIN_VALUE];
                                var YJ=[Number.MAX_VALUE, Number.MIN_VALUE];
                                var ZJ=[Number.MAX_VALUE, Number.MIN_VALUE];
                                for(var k = 0; k <8 ; k++) {
                                    var point = this.project(meshes[i].OABB[k], transformMatrixJ, worldMatrixJ);
                                    if (point.Coordinates.x>XJ[1]) XJ[1]=point.Coordinates.x;
                                    if (point.Coordinates.x<XJ[0]) XJ[0]=point.Coordinates.x;
                                    if (point.Coordinates.y>YJ[1]) YJ[1]=point.Coordinates.y;
                                    if (point.Coordinates.y<YJ[0]) YJ[0]=point.Coordinates.y;
                                    if (point.Coordinates.z>ZJ[1]) ZJ[1]=point.Coordinates.z;
                                    if (point.Coordinates.z<ZJ[0]) ZJ[0]=point.Coordinates.z;
                                }
                                if((XI[0] <= XJ[1] && XI[1] >= XJ[0]) && (YI[0] <= YJ[1] && YI[1] >= YJ[0]) && (ZI[0] <= ZJ[1] && ZI[1] >= ZJ[0])){
                                    console.log("intersection");
                                } 
                            }
                        }
                    }
                };

                Device.prototype.selectBB =function(coords){
                    var near=[];
                    for(var i=0; i<meshes.length; i++){
                        var worldMatrix = BABYLON.Matrix.RotationYawPitchRoll(meshes[i].Rotation.y, meshes[i].Rotation.x, meshes[i].Rotation.z).multiply(BABYLON.Matrix.Translation(meshes[i].Position.x, meshes[i].Position.y, meshes[i].Position.z));
                        var transformMatrix = worldMatrix.multiply(viewMatrix).multiply(projectionMatrix);
                        var X=[Number.MAX_VALUE, Number.MIN_VALUE];
                        var Y=[Number.MAX_VALUE, Number.MIN_VALUE];
                        var maxZ=Number.MIN_VALUE;//get maximum z value of the bounding box of each mesh
                        for(var j = 0; j <8 ; j++) {
                            var point = this.project(meshes[i].OABB[j], transformMatrix, worldMatrix);
                            if (point.Coordinates.x>X[1]) X[1]=point.Coordinates.x;
                            if (point.Coordinates.x<X[0]) X[0]=point.Coordinates.x;
                            if (point.Coordinates.y>Y[1]) Y[1]=point.Coordinates.y;
                            if (point.Coordinates.y<Y[0]) Y[0]=point.Coordinates.y;
                            if (point.Coordinates.z>maxZ){
                                maxZ=point.Coordinates.z;
                            }
                        }
                        if(coords.x<=X[1] && coords.x>=X[0] && coords.y<=Y[1] && coords.y>=Y[0] && meshes[i].Position.z<=cam.Position.z){
                            near.push({z:maxZ, mesh:meshes[i]});
                        }
                    }
                    near.sort(function(a, b) {
                        return b.z - a.z;
                    });
                    if(near.length!=0){
                        alert("selected "+near[0].mesh.name);
                        selectedBB = near[0].mesh;
                    }
                };
                Device.prototype.drawLine = function(p0, p1){
                    var dist= p1.subtract(p0).length();
                    if (dist<30){return;}
                    var md=p0.add((p1.subtract(p0)).scale(0.5));
                    this.drawPoint(md, new BABYLON.Color4(1,0.5,0, 0.5));
                    this.drawLine(p0,md);
                    this.drawLine(md,p1);
                };
                Device.prototype.drawBline = function (point0, point1) {
                    var x0 = point0.x >> 0;
                    var y0 = point0.y >> 0;
                    var x1 = point1.x >> 0;
                    var y1 = point1.y >> 0;
                    var dx = Math.abs(x1 - x0);
                    var dy = Math.abs(y1 - y0);
                    var sx = (x0 < x1) ? 1 : -1;
                    var sy = (y0 < y1) ? 1 : -1;
                    var err = dx - dy;
                    while(true) {
                        this.drawPoint(new BABYLON.Vector2(x0, y0), new BABYLON.Color4(1,0.5,0, 0.5));
                        if((x0 == x1) && (y0 == y1)) break;
                        var e2 = 2 * err;
                        if(e2 > -dy) { err -= dy; x0 += sx; }
                        if(e2 < dx) { err += dx; y0 += sy; }
                    }
                };
                Device.prototype.LoadJSONFileAsync = function (fileName, callback) {
                    var jsonObject = {};
                    var xmlhttp = new XMLHttpRequest();
                    xmlhttp.open("GET", fileName, true);
                    var that = this;
                    xmlhttp.onreadystatechange = function () {
                        if(xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                            jsonObject = JSON.parse(xmlhttp.responseText);
                            callback(that.CreateMeshesFromJSON(jsonObject));
                        }
                    };
                    xmlhttp.send(null);
                };
                Device.prototype.CreateMeshesFromJSON = function (jsonObject) {
                    var materials = [];
                    for (var materialIndex = 0; materialIndex < jsonObject.materials.length; materialIndex++) {
                        var material = {};
                        material.Name = jsonObject.materials[materialIndex].name;
                        material.ID = jsonObject.materials[materialIndex].id;
                        if (jsonObject.materials[materialIndex].diffuseTexture)
                            material.DiffuseTextureName = jsonObject.materials[materialIndex].diffuseTexture.name;
                        materials[material.ID] = material;
                    }
                    for(var meshIndex = 0; meshIndex < jsonObject.meshes.length; meshIndex++) {
                        var verticesArray = jsonObject.meshes[meshIndex].vertices;
                        var indicesArray = jsonObject.meshes[meshIndex].indices;
                        var uvCount = jsonObject.meshes[meshIndex].uvCount;
                        var verticesStep = 1;
                        switch(uvCount) {
                            case 0:
                                verticesStep = 6;
                                break;
                            case 1:
                                verticesStep = 8;
                                break;
                            case 2:
                                verticesStep = 10;
                                break;
                        }
                        var verticesCount = verticesArray.length / verticesStep;
                        var facesCount = indicesArray.length / 3;
                        var mesh = new SoftEngine.Mesh(jsonObject.meshes[meshIndex].name);
                        var oabbx=[Number.MAX_VALUE, Number.MIN_VALUE], oabby=[Number.MAX_VALUE, Number.MIN_VALUE], oabbz=[Number.MAX_VALUE, Number.MIN_VALUE];
                        for (var index = 0; index < verticesCount; index++) {
                            var x = verticesArray[index * verticesStep];
                            var y = verticesArray[index * verticesStep + 1];
                            var z = verticesArray[index * verticesStep + 2];
                            var nx = verticesArray[index * verticesStep + 3];
                            var ny = verticesArray[index * verticesStep + 4];
                            var nz = verticesArray[index * verticesStep + 5];
                            if (x>oabbx[1]) oabbx[1]=x;
                            if (x<oabbx[0]) oabbx[0]=x;
                            if (y>oabby[1]) oabby[1]=y;
                            if (y<oabby[0]) oabby[0]=y;
                            if (z>oabbz[1]) oabbz[1]=z;
                            if (z<oabbz[0]) oabbz[0]=z;
                            mesh.Vertices[index] = {
                                Coordinates: new BABYLON.Vector3(x, y, z),
                                Normal: new BABYLON.Vector3(nx, ny, nz),
                                WorldCoordinates: null
                            };
                            if (uvCount > 0) {
                                var u = verticesArray[index * verticesStep + 6];
                                var v = verticesArray[index * verticesStep + 7];
                                mesh.Vertices[index].TextureCoordinates = new BABYLON.Vector2(u, v);
                            } else {
                                mesh.Vertices[index].TextureCoordinates = new BABYLON.Vector2(0, 0);
                            }
                        }
                        for(var index = 0; index < facesCount; index++) {
                            var a = indicesArray[index * 3];
                            var b = indicesArray[index * 3 + 1];
                            var c = indicesArray[index * 3 + 2];
                            mesh.Faces[index] = {
                                A: a,
                                B: b,
                                C: c
                            };
                        }
                        var position = jsonObject.meshes[meshIndex].position;
                        mesh.Position = new BABYLON.Vector3(position[0], position[1], position[2]);
                        if (uvCount > 0) {
                            var meshTextureID = jsonObject.meshes[meshIndex].materialId;
                            var meshTextureName = materials[meshTextureID].DiffuseTextureName;
                            mesh.Texture = new Texture(meshTextureName, 512, 512);
                        }
                        var oa_bb=[]
                        oabbx.forEach(function(vx){
                            oabby.forEach(function(vy){
                                oabbz.forEach(function(vz){
                                    oa_bb.push({
                                      Coordinates: new BABYLON.Vector3(vx, vy, vz),
                                      Normal: new BABYLON.Vector3(vx, vy, vz)})
                                });
                            });
                        });
                        mesh.OABB=oa_bb;
                        meshes.push(mesh);
                    }
                    return meshes;
                };
                /*Device.prototype.calculateAABB = function(mesh){
                   var worldMatrix = BABYLON.Matrix.RotationYawPitchRoll(mesh.Rotation.y, mesh.Rotation.x, mesh.Rotation.z).multiply(BABYLON.Matrix.Translation(mesh.Position.x, mesh.Position.y, mesh.Position.z));
                   var aabbx=[Number.MAX_VALUE, Number.MIN_VALUE], aabby=[Number.MAX_VALUE, Number.MIN_VALUE], aabbz=[Number.MAX_VALUE, Number.MIN_VALUE];
                   for(var i=0; i<8; i++){
                        mesh.AABB[i].Coordinates = BABYLON.Vector3.TransformCoordinates(mesh.AABB[i].Coordinates, worldMatrix);
                        mesh.AABB[i].Normal = mesh.AABB[i].Coordinates;
                        if (mesh.AABB[i].Coordinates.x>aabbx[1]) aabbx[1]=mesh.AABB[i].Coordinates.x;
                        if (mesh.AABB[i].Coordinates.x<aabbx[0]) aabbx[0]=mesh.AABB[i].Coordinates.x;
                        if (mesh.AABB[i].Coordinates.y>aabby[1]) aabby[1]=mesh.AABB[i].Coordinates.y;
                        if (mesh.AABB[i].Coordinates.y<aabby[0]) aabby[0]=mesh.AABB[i].Coordinates.y;
                        if (mesh.AABB[i].Coordinates.z>aabbz[1]) aabbz[1]=mesh.AABB[i].Coordinates.z;
                        if (mesh.AABB[i].Coordinates.z<aabbz[0]) aabbz[0]=mesh.AABB[i].Coordinates.z;
                   }
                    var aa_bb=[]
                     aabbx.forEach(function(vx){
                       aabby.forEach(function(vy){
                         aabbz.forEach(function(vz){
                             aa_bb.push({
                                 Coordinates: new BABYLON.Vector3(vx, vy, vz),
                                 Normal: new BABYLON.Vector3(vx, vy, vz)})
                         });
                       });
                   });
                     mesh.AABB=aa_bb;
                };*/
                Device.prototype.clamp = function (value, min, max) {
                    if (typeof min === "undefined") { min = 0; }
                    if (typeof max === "undefined") { max = 1; }
                    return Math.max(min, Math.min(value, max));
                };
                Device.prototype.interpolate = function (min, max, gradient) {
                    return min + (max - min) * this.clamp(gradient);
                };
                Device.prototype.processScanLine = function (data, va, vb, vc, vd, color, texture) {
                    var pa = va.Coordinates;
                    var pb = vb.Coordinates;
                    var pc = vc.Coordinates;
                    var pd = vd.Coordinates;
                    var gradient1 = pa.y != pb.y ? (data.currentY - pa.y) / (pb.y - pa.y) : 1;
                    var gradient2 = pc.y != pd.y ? (data.currentY - pc.y) / (pd.y - pc.y) : 1;
                    var sx = this.interpolate(pa.x, pb.x, gradient1) >> 0;
                    var ex = this.interpolate(pc.x, pd.x, gradient2) >> 0;
                    var z1 = this.interpolate(pa.z, pb.z, gradient1);
                    var z2 = this.interpolate(pc.z, pd.z, gradient2);
                    var snl = this.interpolate(data.ndotla, data.ndotlb, gradient1);
                    var enl = this.interpolate(data.ndotlc, data.ndotld, gradient2);
                    var su = this.interpolate(data.ua, data.ub, gradient1);
                    var eu = this.interpolate(data.uc, data.ud, gradient2);
                    var sv = this.interpolate(data.va, data.vb, gradient1);
                    var ev = this.interpolate(data.vc, data.vd, gradient2);
                    for (var x = sx; x < ex; x++) {
                            var gradient = (x - sx) / (ex - sx);
                            var z = this.interpolate(z1, z2, gradient);
                            var ndotl = this.interpolate(snl, enl, gradient);
                            var u = this.interpolate(su, eu, gradient);
                            var v = this.interpolate(sv, ev, gradient);
                            var textureColor;
                            if (texture){
                                textureColor = texture.map(u, v);
                            }
                            else{
                                textureColor = new BABYLON.Color4(1, 1, 1, 1);
                            }
                            this.drawPoint(new BABYLON.Vector3(x, data.currentY, z), 
                                           new BABYLON.Color4(color.r * ndotl* textureColor.r, color.g * ndotl* textureColor.g, color.b * ndotl* textureColor.b, textureColor.a));
                        }
                };
                Device.prototype.computeNDotL = function (vertex, normal, lightPosition) {
                    var lightDirection = lightPosition.subtract(vertex);
                    normal.normalize();
                    lightDirection.normalize();
                    return Math.max(0, BABYLON.Vector3.Dot(normal, lightDirection));
                };
                Device.prototype.drawTriangle = function (v1, v2, v3, color, texture) {
                    if (v1.Coordinates.y > v2.Coordinates.y) {
                        var temp = v2;
                        v2 = v1;
                        v1 = temp;
                    }
                    if (v2.Coordinates.y > v3.Coordinates.y) {
                        var temp = v2;
                        v2 = v3;
                        v3 = temp;
                    }
                    if (v1.Coordinates.y > v2.Coordinates.y) {
                        var temp = v2;
                        v2 = v1;
                        v1 = temp;
                    }
                    var p1 = v1.Coordinates;
                    var p2 = v2.Coordinates;
                    var p3 = v3.Coordinates;
                    var lightPos = new BABYLON.Vector3(0, 0, 10);
                    var data = {};
                    var dP1P2;
                    var dP1P3;
                    var nl1 = this.computeNDotL(v1.WorldCoordinates, v1.Normal, lightPos);
                    var nl2 = this.computeNDotL(v2.WorldCoordinates, v2.Normal, lightPos);
                    var nl3 = this.computeNDotL(v3.WorldCoordinates, v3.Normal, lightPos);
                    if (p2.y - p1.y > 0)
                        dP1P2 = (p2.x - p1.x) / (p2.y - p1.y); else
                        dP1P2 = 0;
                    if (p3.y - p1.y > 0)
                        dP1P3 = (p3.x - p1.x) / (p3.y - p1.y); else
                        dP1P3 = 0;
                
                    if (dP1P2 > dP1P3) {
                        for (var y = p1.y >> 0; y <= p3.y >> 0; y++) {
                            data.currentY = y;
                            if (y < p2.y) {
                                data.ndotla = nl1;
                                data.ndotlb = nl3;
                                data.ndotlc = nl1;
                                data.ndotld = nl2;
                                data.ua = v1.TextureCoordinates.x;
                                data.ub = v3.TextureCoordinates.x;
                                data.uc = v1.TextureCoordinates.x;
                                data.ud = v2.TextureCoordinates.x;
                                data.va = v1.TextureCoordinates.y;
                                data.vb = v3.TextureCoordinates.y;
                                data.vc = v1.TextureCoordinates.y;
                                data.vd = v2.TextureCoordinates.y;
                                this.processScanLine(data, v1, v3, v1, v2, color, texture);
                            } else {
                                data.ndotla = nl1;
                                data.ndotlb = nl3;
                                data.ndotlc = nl2;
                                data.ndotld = nl3;
                                data.ua = v1.TextureCoordinates.x;
                                data.ub = v3.TextureCoordinates.x;
                                data.uc = v2.TextureCoordinates.x;
                                data.ud = v3.TextureCoordinates.x;
                                data.va = v1.TextureCoordinates.y;
                                data.vb = v3.TextureCoordinates.y;
                                data.vc = v2.TextureCoordinates.y;
                                data.vd = v3.TextureCoordinates.y;
                                this.processScanLine(data, v1, v3, v2, v3, color, texture);
                            }
                        }
                    }
                    else {
                        for (var y = p1.y >> 0; y <= p3.y >> 0; y++) {
                            data.currentY = y;
                            if (y < p2.y) {
                                data.ndotla = nl1;
                                data.ndotlb = nl2;
                                data.ndotlc = nl1;
                                data.ndotld = nl3;
                                data.ua = v1.TextureCoordinates.x;
                                data.ub = v2.TextureCoordinates.x;
                                data.uc = v1.TextureCoordinates.x;
                                data.ud = v3.TextureCoordinates.x;
                                data.va = v1.TextureCoordinates.y;
                                data.vb = v2.TextureCoordinates.y;
                                data.vc = v1.TextureCoordinates.y;
                                data.vd = v3.TextureCoordinates.y;
                                this.processScanLine(data, v1, v2, v1, v3, color, texture);
                            } else {
                                data.ndotla = nl2;
                                data.ndotlb = nl3;
                                data.ndotlc = nl1;
                                data.ndotld = nl3;
                                data.ua = v2.TextureCoordinates.x;
                                data.ub = v3.TextureCoordinates.x;
                                data.uc = v1.TextureCoordinates.x;
                                data.ud = v3.TextureCoordinates.x;
                                data.va = v2.TextureCoordinates.y;
                                data.vb = v3.TextureCoordinates.y;
                                data.vc = v1.TextureCoordinates.y;
                                data.vd = v3.TextureCoordinates.y;
                                this.processScanLine(data, v2, v3, v1, v3, color, texture);
                            }
                        }
                    }
                };
                return Device;
        }) ();
        SoftEngine.Device = Device;

        })(SoftEngine={});
        
        var canvas;
        var mesh;
        var device;
        var prev = 0;
        var mouseCoord={x: -1, y: -1};
        document.addEventListener("DOMContentLoaded", init, false);
        function init() {
            canvas = document.getElementById("frontBuffer");
            canvas.width= window.innerWidth;
            canvas.height=window.innerHeight;
            cam = new SoftEngine.Camera();
            device = new SoftEngine.Device(canvas);
            cam.Position = new BABYLON.Vector3(0, 0, 25);
            cam.Target = new BABYLON.Vector3(0, 0, 0);
        }
        function initJSON(){
            objCount+=1;
            prev=0;
            if (song){
                song.pause();
            }
            device.LoadJSONFileAsync("suzanne.babylon", loadJSONCompleted);
        }
        function initVizer(){
            objCount+=1;
            if(!song){
                alert("Drop an audio file");
            }
            prev=0;
            mesh = new SoftEngine.Mesh("Sphere"+objCount.toString());
            var k=0;
            var x, y, z;
            var oabbx=[Number.MAX_VALUE, Number.MIN_VALUE], oabby=[Number.MAX_VALUE, Number.MIN_VALUE], oabbz=[Number.MAX_VALUE, Number.MIN_VALUE];
            for(var i=0; i<=2*3.14; i=i+0.157){
                for(var j=0; j<=3.14; j+=0.157){
                    x=Math.cos(i)*Math.sin(j);
                    y=Math.sin(i)*Math.sin(j);
                    z=Math.cos(j);
                    if (x>oabbx[1]) oabbx[1]=x;
                    if (x<oabbx[0]) oabbx[0]=x;
                    if (y>oabby[1]) oabby[1]=y;
                    if (y<oabby[0]) oabby[0]=y;
                    if (z>oabbz[1]) oabbz[1]=z;
                    if (z<oabbz[0]) oabbz[0]=z;
                    mesh.Vertices[k] = {
                                            Coordinates: new BABYLON.Vector3(x, y, z),
                                            Normal: new BABYLON.Vector3(x, y, z),
                                            WorldCoordinates: null,
                                        };
                    k+=1;
                }
            }
            mesh.Vertices[k] = {   
                                    Coordinates: new BABYLON.Vector3(0, 0, 0),
                                    Normal: new BABYLON.Vector3(0, 0, 0),
                                    WorldCoordinates: null
                                };
            var oa_bb=[]
            oabbx.forEach(function(vx){
              oabby.forEach(function(vy){
                oabbz.forEach(function(vz){
                    oa_bb.push({
                        Coordinates: new BABYLON.Vector3(vx, vy, vz),
                        Normal: new BABYLON.Vector3(vx, vy, vz)})
                });
              });
          });
            mesh.OABB=oa_bb; 
            mesh.animFreq='all';
            meshes.push(mesh);
            
        }
        function setFreq(freq){
            if (!song.isPlaying()){
                song.play();
            };
            mesh.animFreq=freq;
            requestAnimationFrame(drawVis);
        }
        function loadJSONCompleted(meshesLoaded) {
            meshes = meshesLoaded;
            requestAnimationFrame(drawJSON);
        }
        function drawJSON() {            
            device.clear();
            for (var i = 0; i < meshes.length; i++) {
                meshes[i].Rotation.y += 0.01;
            }
            device.render(cam, meshes, "faces");
            device.present();
            requestAnimationFrame(drawJSON);
            var currFPS = 1000.0/(performance.now() - prev) ;
            document.getElementById("p1").innerHTML = currFPS>>0;
            prev=performance.now();
        }
        function drawVis() {
            document.getElementById("p1").innerHTML = "FPS!";
            var rangeslider = document.getElementById("myRange");
            song.amp(rangeslider.value/100);            
            device.clear();
            var spectrum = fft.analyze();
            var lowlvl = fft.getEnergy("bass", "lowMid", "mid", "highMid", "treble");
            meshes.forEach(function(m){
                if(m.animFreq==='all'){
                    rms = fft.getEnergy("bass", "treble")/255;
                }
                else{
                    rms = fft.getEnergy(m.animFreq)/255;
                }
                m.Rotation.y += rms/20;
                if(rms>0.7)m.Position.z+=rms/16;
                else if(m.Position.z>=0)m.Position.z-=1.5;
            });
            device.render(cam, meshes, "volume");
            device.present();
            requestAnimationFrame(drawVis);
        }
        function myFunction() {
            document.getElementById("myDropdown").classList.toggle("show");
        }
        window.onclick = function(event) {
            mouseCoord.x=event.clientX;
            mouseCoord.y=event.clientY;
            device.selectBB(mouseCoord, cam);

          if (!event.target.matches('.dropbtn')) {

            var dropdowns = document.getElementsByClassName("dropdown-content");
            for (var i = 0; i < dropdowns.length; i++) {
              var openDropdown = dropdowns[i];
              if (openDropdown.classList.contains('show')) {
                openDropdown.classList.remove('show');
              }
            }
          }
        }
        var trans=false;
        var rot=false;
        var direction;
        window.onkeydown = function(event) {
            var key = event.keyCode;
            event.preventDefault();
            if(selectedBB){
                if (key===84){
                    trans=true;
                    rot=false
                }
                if (key===82){
                    rot=true;
                    trans=false;
                }
                if(trans || rot){
                    if (key===88) direction ='x';
                    if (key===89) direction ='y';
                    if (key===90) direction ='z';
                    if (key===27){
                        trans=false;
                        rot=false;
                    }
                }

                if(trans){
                    if(direction==='x'){
                        if      (key === 38 || key === 39) selectedBB.Position.x+=0.1;
                        else if (key === 37 || key === 40) selectedBB.Position.x-=0.1;
                    }
                    else if(direction==='y'){
                        if      (key === 38 || key === 39) selectedBB.Position.y+=0.1;
                        else if (key === 37 || key === 40) selectedBB.Position.y-=0.1;
                    }
                    else if(direction==='z'){
                        if      (key === 38 || key === 39) selectedBB.Position.z+=0.1;
                        else if (key === 37 || key === 40) selectedBB.Position.z-=0.1;
                    }
                    else{
                        if(key === 37) selectedBB.Position.x-=0.1;
                        else if(key === 38) selectedBB.Position.y+=0.1;
                        else if(key === 39) selectedBB.Position.x+=0.1;
                        else if(key === 40) selectedBB.Position.y-=0.1;
                    }

                }
                if(rot){
                    if(direction==='x'){
                        if      (key === 38 || key === 39) selectedBB.Rotation.x+=0.1;
                        else if (key === 37 || key === 40) selectedBB.Rotation.x-=0.1;
                    }
                    else if(direction==='y'){
                        if      (key === 38 || key === 39) selectedBB.Rotation.y+=0.1;
                        else if (key === 37 || key === 40) selectedBB.Rotation.y-=0.1;
                    }
                    else if(direction==='z'){
                        if      (key === 38 || key === 39) selectedBB.Rotation.z+=0.1;
                        else if (key === 37 || key === 40) selectedBB.Rotation.z-=0.1;
                    }
                    else{
                        if(key === 37) selectedBB.Position.x-=0.1;
                        else if(key === 38) selectedBB.Position.y+=0.1;
                        else if(key === 39) selectedBB.Position.x+=0.1;
                        else if(key === 40) selectedBB.Position.y-=0.1;
                    }

                }
                
            }
        };
    </script>
</head>
<body>
    <canvas id="frontBuffer" style="background-color: black;"></canvas>
    <div id="controls">
        <button onclick="initJSON()">Load JSON File</button>
        <button onclick="initVizer()">Create new visualizer</button>
        <div class="dropdown">
        <button onclick="myFunction()" class="dropbtn">Visualizing Frequencies</button>
          <div id="myDropdown" class="dropdown-content">
            <a onclick="setFreq('bass')">Bass</a>
            <a onclick="setFreq('lowMid')">LowMid</a>
            <a onclick="setFreq('mid')">Mid</a>
            <a onclick="setFreq('highMid')">HighMid</a>
            <a onclick="setFreq('treble')">Treble</a>
            <a onclick="setFreq('all')">Whole Band</a>
          </div>
        </div>
        <button onclick="gotAudio()">Pause</button>
        <div class="slidecontainer">
            <p> &ensp; Volume: </p>
          <input type="range" min="1" max="100" value="50" class="slider" id="myRange">
          <p id="p1"> &ensp;&ensp;&ensp;&ensp;FPS! <p>
        </div>
    </div>
</body>
</html>